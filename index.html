#include <ESP8266WiFi.h>
#include <WiFiManager.h>      
#include <PubSubClient.h>     
#include <EEPROM.h>
#include <ESP8266HTTPClient.h>
#include <WiFiClientSecureBearSSL.h>

// --- OneSignal Configuration ---
const char* oneSignalAppID = "a71c864f-2514-4798-b919-4511e0801b5a";
const char* oneSignalAPIKey = "os_v2_app_u4oimtzfcrdzroiziui6baa3llihcziuk5tujufcfl35ujs6dbszhey62f4nc3e3jfgfpegkv5657xzzix5kyaqxmldleuvs7su5zxq";

#define PIN_UP      D2 
#define PIN_STOP    D5 
#define PIN_DOWN    D7 
#define PIN_SENSOR  D1 
#define PIN_RESET   D3 
#define PIN_WIFI_OK D4 
#define PIN_SETUP   D8 

const char* mqtt_server = "broker.hivemq.com"; 
WiFiClient espClient;
PubSubClient client(espClient);
String deviceID, topic_sub, topic_pub;
int lastSensorState = -1;
bool inSetupMode = false;
bool isAppCommand = false; 
unsigned long doorOpenStart = 0;
int alertCount = 0; 
unsigned long lastHeartbeatSend = 0;

struct Settings {
  int autoTime;
  int autoEnabled;
  char userPIN[6];
} userConfig;

// --- Push Notification Function ---
void sendPushNotification(String message) {
  if (WiFi.status() != WL_CONNECTED) return;
  for (int attempt = 0; attempt < 3; attempt++) {
    std::unique_ptr<BearSSL::WiFiClientSecure> secureClient(new BearSSL::WiFiClientSecure);
    secureClient->setBufferSizes(1024, 1024); 
    secureClient->setInsecure(); 
    HTTPClient https;
    https.setTimeout(8000);
    if (https.begin(*secureClient, "https://onesignal.com/api/v1/notifications")) {
      https.addHeader("Content-Type", "application/json");
      https.addHeader("Authorization", "Key " + String(oneSignalAPIKey));
      String payload = "{"
        "\"app_id\":\"" + String(oneSignalAppID) + "\","
        "\"included_segments\":[\"Total Subscriptions\"],"
        "\"headings\":{\"en\":\"SAMXI SECURITY\"},"
        "\"contents\":{\"en\":\"" + message + "\"},"
        "\"priority\":10,"
        "\"android_visibility\":1,"
        "\"android_accent_color\":\"FFFF0000\","
        "\"android_channel_id\":\"a48f3ffc-d2ec-4220-a4f1-1525edb1d410\""
      "}";
      int httpCode = https.POST(payload);
      if (httpCode == 200) { https.end(); break; } 
      else { https.end(); delay(500); yield(); }
    }
  }
}

void startPortal() {
  inSetupMode = true;
  digitalWrite(PIN_WIFI_OK, LOW);
  digitalWrite(PIN_SETUP, HIGH); 
  strcpy(userConfig.userPIN, "1234");
  EEPROM.put(0, userConfig); EEPROM.commit();
  WiFi.disconnect(true);
  delay(1000);
  WiFi.mode(WIFI_OFF);
  delay(1000);
  WiFi.mode(WIFI_AP_STA);
  WiFiManager wm;
  wm.resetSettings(); 
  if (!wm.startConfigPortal("SAMXI_SMART_DOOR_SETUP")) { ESP.restart(); }
  ESP.restart();
}

void setup() {
  Serial.begin(115200);
  system_update_cpu_freq(160); 
  delay(500);
  deviceID = "SAMXI_" + String(ESP.getChipId());
  EEPROM.begin(512);
  EEPROM.get(0, userConfig);
  if (userConfig.autoTime < 1 || userConfig.autoTime > 255) {
    userConfig.autoTime = 12; userConfig.autoEnabled = 1;
    strcpy(userConfig.userPIN, "1234");
    EEPROM.put(0, userConfig); EEPROM.commit();
  }
  pinMode(PIN_UP, OUTPUT); pinMode(PIN_STOP, OUTPUT); pinMode(PIN_DOWN, OUTPUT);
  pinMode(PIN_WIFI_OK, OUTPUT); pinMode(PIN_SETUP, OUTPUT);
  pinMode(PIN_SENSOR, INPUT_PULLUP); 
  pinMode(PIN_RESET, INPUT_PULLUP);
  topic_sub = "samxi/" + deviceID + "/cmd";
  topic_pub = "samxi/" + deviceID + "/state";
  WiFi.mode(WIFI_STA);
  WiFi.setSleepMode(WIFI_NONE_SLEEP);
  WiFi.begin(); 
  client.setServer(mqtt_server, 1883);
  client.setCallback(callback);
}

void reconnect() {
  if (WiFi.status() != WL_CONNECTED) return;
  if (!client.connected()) {
    if (client.connect(deviceID.c_str(), topic_pub.c_str(), 1, true, "OFFLINE")) {
      client.subscribe(topic_sub.c_str());
      client.publish(topic_pub.c_str(), "ONLINE", true);
    }
  }
}

void loop() {
  if (digitalRead(PIN_RESET) == LOW) {
    unsigned long start = millis();
    while(digitalRead(PIN_RESET) == LOW) {
      if(millis() - start > 5000) startPortal();
      delay(10);
    }
  }

  if (!inSetupMode) {
    if (WiFi.status() == WL_CONNECTED) {
      if (!client.connected()) reconnect();
      else client.loop();
    }
    digitalWrite(PIN_WIFI_OK, client.connected() ? HIGH : LOW);
    
    int s = digitalRead(PIN_SENSOR);
    if (s != lastSensorState) {
      if(client.connected()) {
          client.publish(topic_pub.c_str(), (s == HIGH) ? "OPEN" : "CLOSED", true);
      }
      
      if (s == HIGH) {
        doorOpenStart = millis();
        alertCount = 0;
        if (isAppCommand) {
          sendPushNotification("SUCCESS: The Smart Door was Opened via APP.");
          isAppCommand = false; 
        } else {
          sendPushNotification("SECURITY ALERT:The Smart Door has been OPENED.");
        }
      }
      else if (s == LOW && lastSensorState != -1) {
        alertCount = 0; 
        if (isAppCommand) {
          sendPushNotification("SUCCESS: The Smart Door was Closed via APP.");
          isAppCommand = false; 
        } else {
          sendPushNotification("SUCCESS: The Smart Door has been CLOSED.");
        }
      }
      lastSensorState = s;
    }

    if (s == HIGH) {
        unsigned long totalSecs = (millis() - doorOpenStart) / 1000;
        int currentAlertCount = totalSecs / 300; 
        if (currentAlertCount > alertCount) {
            alertCount = currentAlertCount;
            int h = totalSecs / 3600;
            int m = (totalSecs % 3600) / 60;
            String timeStr = (h > 0) ? String(h) + (h == 1 ? " hr " : " hrs ") : "";
            timeStr += String(m) + " min";
            sendPushNotification("SECURITY WARNING: The door is still open after " + timeStr + "!");
            if(client.connected()) client.publish(topic_pub.c_str(), "ALERT|STILL_OPEN");
        }
    }

    if (millis() - lastHeartbeatSend > 2000) {
      if(client.connected()) {
        // --- MODIFICATION: ADDED SENSOR STATE TO DATA PACKET ---
        String sensorStatus = (digitalRead(PIN_SENSOR) == HIGH) ? "OPEN" : "CLOSED";
        String data = "DATA|" + String(WiFi.RSSI()) + "|" + String(userConfig.autoEnabled) + "|" + String(userConfig.autoTime) + "|" + sensorStatus;
        client.publish(topic_pub.c_str(), data.c_str(), true);
      }
      lastHeartbeatSend = millis();
    }
  }
}

void callback(char* topic, byte* payload, unsigned int length) {
  String msg = "";
  for (int i = 0; i < length; i++) msg += (char)payload[i];

  if (msg == "RESET_FACTORY") startPortal();
  if (msg == "GET_STATE") {
     String sensorStatus = (digitalRead(PIN_SENSOR) == HIGH) ? "OPEN" : "CLOSED";
     String data = "DATA|" + String(WiFi.RSSI()) + "|" + String(userConfig.autoEnabled) + "|" + String(userConfig.autoTime) + "|" + sensorStatus;
     client.publish(topic_pub.c_str(), data.c_str(), true);
  }
  if (msg.startsWith("VERIFY|")) {
    String p = msg.substring(7);
    client.publish(topic_pub.c_str(), (p == String(userConfig.userPIN)) ? "PIN_OK" : "WRONG_PIN");
  }
  else if (msg == "up") { 
    isAppCommand = true; 
    digitalWrite(PIN_UP, HIGH); delay(800); digitalWrite(PIN_UP, LOW); 
  }
  else if (msg == "stop") { 
    client.publish(topic_pub.c_str(), "PAUSED"); 
    digitalWrite(PIN_STOP, HIGH); delay(500); digitalWrite(PIN_STOP, LOW);
  }
  else if (msg == "down") { 
    isAppCommand = true; 
    digitalWrite(PIN_DOWN, HIGH); delay(800); digitalWrite(PIN_DOWN, LOW);
  }
  else if (msg == "auto" && userConfig.autoEnabled == 1) {
    isAppCommand = true; 
    client.publish(topic_pub.c_str(), "START_AUTO");
    digitalWrite(PIN_UP, HIGH); delay(800); digitalWrite(PIN_UP, LOW);
  }
}
